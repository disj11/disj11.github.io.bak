<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="https://disj11.github.io/tag/database/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://disj11.github.io/" rel="alternate" type="text/html" />
  <updated>2019-10-29T12:00:08+00:00</updated>
  <id>https://disj11.github.io/tag/database/feed.xml</id>

  
  
  

  
    <title type="html">Life Log | </title>
  

  
    <subtitle>Record my life</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">RBAC (Role Based Access Control - 역할 기반 접근 제어)</title>
      <link href="https://disj11.github.io/role-based-access-control" rel="alternate" type="text/html" title="RBAC (Role Based Access Control - 역할 기반 접근 제어)" />
      <published>2019-06-15T02:30:00+00:00</published>
      <updated>2019-06-15T02:30:00+00:00</updated>
      <id>https://disj11.github.io/role-based-access-control</id>
      <content type="html" xml:base="https://disj11.github.io/role-based-access-control">&lt;h3 id=&quot;잡담&quot;&gt;잡담&lt;/h3&gt;
&lt;p&gt;역할 기반 접근 제어를 사용할 일이 필요해 검색을 하던 중,
&lt;a href=&quot;https://stackoverflow.com/questions/28157798/is-my-role-based-access-control-a-feasible-solution/28159647#28159647&quot;&gt;좋은 글&lt;/a&gt;을 찾아 포스팅을 하게 되었습니다.
역할 기반 접근 제어의 설명보다는, 구현 방법에 대해 알아보기 위한 글입니다.&lt;/p&gt;

&lt;h3 id=&quot;소개&quot;&gt;소개&lt;/h3&gt;
&lt;p&gt;역할 기반 접근 제어는 사용자의 역할에 따라 권한을 구분하고,
권한이 없는 사용자에게는 시스템 접근을 제한하는 방법이다.
사전에 역할을 미리 정의해두고, 사용자에게 역할을 부여함으로써 권한을 제어한다.&lt;/p&gt;

&lt;h3 id=&quot;간단한-솔루션&quot;&gt;간단한 솔루션&lt;/h3&gt;
&lt;p&gt;Stackoverflow 같은 사이트를 만든다고 가정하자.
우리는 아래와 같은 두 가지 모듈이 필요한 상황이다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;질문 (questions)&lt;/li&gt;
  &lt;li&gt;채팅 (chat)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 모듈의 권한을 관리하기 위해서는 아래와 같은 테이블이 필요하다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Modules
- id : 모듈의 고유 ID
- name : 모듈에 대한 설명
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;그리고 이 모듈들이 할 수 있는 액션을 정의한다.
예를 들어 질문 모듈의 경우&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;질문 등록&lt;/li&gt;
  &lt;li&gt;질문 삭제&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;등등 이 있을 수 있고, 채팅 모듈의 경우&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;채팅방 열기&lt;/li&gt;
  &lt;li&gt;강퇴&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;등등이 있을 수 있다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Actions
- module_id : 사전에 정의한 모듈의 ID
- action : 모듈의 기능
- name : 기능에 대한 설명

- Primary Key : [module_id, action]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 두 테이블을 정의한 모습을 보자.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Modules
+------------------------------------------+
| ID        | Name                         |
+------------------------------------------+
| questions | Question and Answer Module   |
| chat      | Chat Module                  |
+------------------------------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Actions
+-----------------------------------------------+
| Module    | Action    |  Name                 |
+-----------------------------------------------+
| questions | read      | Read Questions        |
| questions | create    | Create Questions      |
| questions | edit      | Edit Questions        |
| questions | delete    | Delete Questions      |
|           |           |                       |
| chat      | join      | Join the Chat         |
| chat      | kick      | Kick users            |
| chat      | create    | Create Chatrooms      |
+-----------------------------------------------+  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;여기서 중요한 점은 위 두 테이블은 &lt;em&gt;시스템 관리자가 직접 수정할 수 없는 데이터&lt;/em&gt;이므로,
기능 추가 / 제거와 같은 GUI 가 있어서는 안된다는 점이다.&lt;/p&gt;

&lt;p&gt;여기까지 만들어졌다면 이제는 역할을 만들어야 한다.
역할 테이블은 위 테이블들과는 달리 관리자에 의해 관리될 수 있으며,
기본적으로 아래와 같은 역할이 있을 수 있다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Q&amp;amp;A User:
   - 질문을 읽을 수 있음
   - 질문을 등록 할 수 있음
Q&amp;amp;A Moderator:
   - 질문을 읽을 수 있음
   - 질문을 등록 할 수 있음
   - 질문을 수정할 수 있음
Q&amp;amp;A Admin:
   - 질문을 읽을 수 있음
   - 질문을 등록 할 수 있음
   - 질문을 수정할 수 있음
   - 질문을 삭제 할 수 있음

Chat User:
   - 채팅방에 참여할 수 있음

Chat Moderator:
   - 채팅방에 참여할 수 있음
   - 채팅방에서 사용자를 강퇴할 수 있음

Chat Admin:
   - 채팅방에 참여할 수 있음
   - 채팅방에서 사용자를 강퇴할 수 있음
   - 채팅방을 개설할 수 있음
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;그럼 위 내용을 바탕으로 역할 테이블을 만들어 보자&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Roles
+-----------------------+
| ID | Name             |
+-----------------------+
| 1  | Q&amp;amp;A User         |
| 2  | Q&amp;amp;A Moderator    |
| 3  | Q&amp;amp;A Admin        |
| 4  | Chat User        |
| 5  | Chat Moderator   |
| 6  | Chat Admin       |
+-----------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위와 같은 테이블이 탄생하였다.
이제 역할에서 허용할 기능을 알려줄 &lt;code class=&quot;highlighter-rouge&quot;&gt;roles_actions&lt;/code&gt;을 정의하자.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Roles_Actions
  - role_id
  - module_id 
  - action

  PK: [role_id, module_id, action]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위 테이블에는 아래와 같은 내용이 들어가게 될 것이다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Roles_Actions
+--------------------------------+
| Role ID | Module ID | Action   |
+--------------------------------+
|    1    | questions |  read    |
|    1    | questions |  create  |
|    2    | questions |  read    |
|    2    | questions |  create  |
|    2    | questions |  edit    |
               ...  
|    6    |    chat   |  join    |
|    6    |    chat   |  kick    |
|    6    |    chat   |  create  |
+--------------------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;마지막으로 사용자에게 역할을 부여하기 위한 테이블 &lt;code class=&quot;highlighter-rouge&quot;&gt;users_roles&lt;/code&gt;을 정의하자.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# User_Roles
   - user_id [FK:user_id, unsigned]
   - role_id [FK:roles_id, unsigned]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;테이블의 내용은 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Users_Roles
+---------------------------------+
| User ID | Role ID               |
+---------------------------------+
|    1    |  3 (= Q&amp;amp;A Admin)      |
|    1    |  6 (= Chat Admin)     |
|    2    |  2 (= Q&amp;amp;A Moderator)  |    
|    2    |  4 (= Chat User)      |
|    3    |  2 (= Q&amp;amp;A Moderator)  |  
|    3    |  5 (= Chat Moderator) | 
+---------------------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>Saturday</name>
        
        
      </author>

      

      
        <category term="Database" />
      

      
        <summary type="html">잡담 역할 기반 접근 제어를 사용할 일이 필요해 검색을 하던 중, 좋은 글을 찾아 포스팅을 하게 되었습니다. 역할 기반 접근 제어의 설명보다는, 구현 방법에 대해 알아보기 위한 글입니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Inverted index (역색인)</title>
      <link href="https://disj11.github.io/inverted-index" rel="alternate" type="text/html" title="Inverted index (역색인)" />
      <published>2019-04-24T16:30:00+00:00</published>
      <updated>2019-04-24T16:30:00+00:00</updated>
      <id>https://disj11.github.io/inverted-index</id>
      <content type="html" xml:base="https://disj11.github.io/inverted-index">&lt;h3 id=&quot;소개&quot;&gt;소개&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;Inverted index(역방향 인덱스)는 대용량 텍스트 검색을 위해서 고안된 방법이다.
요즘 많이 사용하는 해시태그 기능을 구현하고 싶다면 역방향 인덱스 방법을 사용할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;기존의-검색-방식&quot;&gt;기존의 검색 방식&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;WHERE =&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT * FROM DOCUMENT WHERE content = 'search text'&lt;/code&gt; &lt;br /&gt;
검색어와 정확히 일치하는 문서만 검색된다.
인덱스가 걸려있을 경우 속도는 빠를 수 있지만, 문서 결과를 거의 얻지 못한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;WHERE LIKE&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT * FROM DOCUMENT WHERE content like '%search text%'&lt;/code&gt; &lt;br /&gt;
검색어가 포함되는 문서를 검색한다.
1번 보다 검색 결과가 많이 나올 순 있지만, 1번과 마찬가지로 검색어와 정확히 일치하는
문장이 포함되어야 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Whitespace tokenizer AND&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT * FROM DOCUMENT WHERE content like '%search% and content like %text%&lt;/code&gt;
검색어의 모든 단어가 포함되는 문서를 검색한다. 2번 방식보다는 향상된 결과를 보여준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Whitespace tokenizer OR&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT * FROM DOCUMENT WHERE content like '%search% and content like %text%&lt;/code&gt; &lt;br /&gt;
검색어의 단어 중 하나의 단어라도 포함되어 있는 문서를 검색한다.
1~3번의 방식 중 가장 많은 결과가 검색되지만, 하나의 단어라도 포함되어 있는 문서는 전부
검색되기 때문에 검색 결과의 정확성이 떨어질 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;기존-방식의-문제&quot;&gt;기존 방식의 문제&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;1번과 같은 검색 방식의 경우 검색 결과를 거의 얻지 못함&lt;/li&gt;
  &lt;li&gt;2~3번과 같은 경우 index를 타지 않기 때문어 검색 속도가 느림
(like 검색시 %를 앞에 넣게되는 경우 인덱스를 타지 않는다.)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;inverted-index&quot;&gt;Inverted index&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;위에서와 같이 기존 검색 방식은 INDEX 기능을 이용할 수 없다는 단점이 있다.
이를 극복하기 위해 단어(Term)로 인덱싱을 하는 Inverted index 방식이 고안되었다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Inverted index는 아래의 표를 통해 쉽게 이해할 수 있다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;term&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;document_id&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;안녕&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1,2,3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;붕어빵&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1,2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;고기&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;위의 표와 같이 역색인은 키워드에 문서의 Pk와 같은 값을 매핑하여 저장하는 기술이다.
역색인 작업을 했을 때의 장점은 검색 속도가 굉장히 빨라진다는 것이다. (term에 인덱스를 사용)&lt;/p&gt;

&lt;p&gt;“안녕 붕어빵”으로 검색 하였을 시 OR 처리를 하였다고 가정한다면,
1, 2, 3번 문서가 검색된다.
여기서 좀 더 발전시켜 문서별 단어 등장 빈도수를 계산하여,
빈도가 높은 순으로 정렬 하는 등 세부적인 처리를 통해
검색 결과의 품질을 높일 수 있다.&lt;/p&gt;

&lt;p&gt;[참고 사이트] &lt;br /&gt;
&lt;a href=&quot;https://blog.lael.be/post/3056&quot; target=&quot;_blank&quot;&gt;https://blog.lael.be/post/3056&lt;/a&gt;
&lt;a href=&quot;https://needjarvis.tistory.com/345&quot; target=&quot;_blank&quot;&gt;https://needjarvis.tistory.com/345&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Saturday</name>
        
        
      </author>

      

      
        <category term="Database" />
      

      
        <summary type="html">소개 Inverted index(역방향 인덱스)는 대용량 텍스트 검색을 위해서 고안된 방법이다. 요즘 많이 사용하는 해시태그 기능을 구현하고 싶다면 역방향 인덱스 방법을 사용할 수 있다.</summary>
      

      
      
    </entry>
  
</feed>
